容器是 Python 中的一个抽象概念，可以简单理解为**包含其他对象的对象**。常见的四种内置容器类型为列表、元组、字典、集合。

除了内置容器类型外，Python 也允许你通过实现对应的魔法方法，来自定义容器。

让我们展开探讨。

## 不可变序列

**序列**是指一种**包含有序对象的容器**，比如列表。

要实现一个最简单的序列，只需要实现 `__len__` 和 `__getitem__` 方法即可：

```python
class Seq:
    def __init__(self, values=[]):
        self.values = values
        
    def __len__(self):
        return len(self.values)
    
    def __getitem__(self, key):
        return self.values[key]
```

因为没有实现如何去修改容器中的对象，因此这是一个**不可变序列**。

`__len__` 方法返回序列的大小，`__getitem__` 方法定义如何对容器进行取值。

测试下：

```python
>>> seq = Seq(values=[1, 2, 3])
>>> len(seq)
3
>>> seq[1]
2
>>> seq[0:2] + seq[1:3]
[1, 2, 2, 3]
```

这已经表现得有点像普通的列表了，对吧？

除此之外，对序列进行**迭代**是非常基本的需求，上面这个自定义序列似乎没有哪里实现了迭代的功能，它能够正常迭代吗？

再试试：

```python
>>> for item in seq:
...     print(item)

# 输出:
1
2
3
```

居然很顺利的迭代出了容器中的值。原因在于 Python 处理迭代时的流程：

- 检查对象是否实现了 `__iter__` 方法。
- 若实现了 `__iter__`，则通过此方法返回的迭代器进行迭代。
- 若未实现 `__iter__` ，则遍历 `__getitem__` 中所有的值进行迭代。

也就是说，虽然没实现 `__iter__` 方法，但是 Python 的“保底机制”让迭代得以成功。

类似的还有判断容器是否包含某元素的 `in` 语句：

```python
>>> 1 in seq
True
>>> 4 in seq
False
```

`in` 语句的执行流程：

- 如果容器定义了 `__contains__` ，则根据此方法判断是否包含当前元素。
- 如果未定义 `__contains__` 但定义了 `__iter__` ，则遍历迭代器的值判断。
- 如果都没定义，那就遍历 `__getitem__` 中的值判断。

除此之外，用于颠倒元素顺序的 `reversed()` 也可以用：

```python
>>> re = reversed(seq)
>>> for item in re:
...     print(item)

# 输出:
3
2
1
```

它也是同样的道理，由 `__len__` 和 `__getitem__` 配合，隐式实现了 `__reversed__` 方法。

虽然上述方法可以隐式实现，但从效率的角度考虑，还是建议手动实现。把它们都补充完整，则一个简单的不可变序列差不多是这样：

```python
class Seq:
    def __init__(self, values=[]):
        self.values = values
        
    def __len__(self):
        return len(self.values)
    
    def __getitem__(self, key):
        return self.values[key]
    
    def __iter__(self):
        return iter(self.values)
    
    def __reversed__(self):
        return reversed(self.values)
    
    def __contains__(self, item):
        return item in self.values
```

## 可变序列

**可变序列**只需要在不可变序列的基础上，增加 `__setitem__` 和 `__delitem__` 以定义如何修改和删除容器中的元素。

此外，也推荐实现 `append()` 、 `insert()` 、 `pop()` 等方法，和 Python 内置的序列保持一致。

比如下面这个自定义的可变序列：

```python
class Seq:
    def __init__(self, values=[]):
        self.values = values
        
    def __len__(self):
        return len(self.values)
    
    def __getitem__(self, key):
        return self.values[key]
    
    def __setitem__(self, key, value):
        self.values[key] = value

    def __delitem__(self, key):
        del self.values[key]
    
    def append(self, value):
        self.values.append(value)
```

## 自带电池

虽然我们可以通过实现魔法方法的形式来自定义几乎所有类型的容器，但那实在是没有必要，因为 Python 有丰富的标准库，开箱即用非常强大。

比方说要实现**可变字典**，不需要自己造轮子实现底层细节，直接继承 `collections.abc.MutableMapping` 并实现上面那几个基础的魔法方法即可：

```python
from collections.abc import MutableMapping

class MyDict(MutableMapping):
    def __init__(self, **kwargs):
        self.data = kwargs
        
    def __getitem__(self, key):
        return self.data[key]
    
    def __delitem__(self, key):
        del self.data[key]
        
    def __setitem__(self, key, value):
        self.data[key] = value
        
    def __iter__(self):
        return iter(self.data)
    
    def __len__(self):
        return len(self.data)
    
    def __repr__(self):
        return repr(self.data)

my_dict = MyDict(a=1, b=2)
my_dict.update(c=3)
my_dict['d'] = 4
my_dict.pop('b')

print(my_dict)
# 输出:
# {'a': 1, 'c': 3, 'd': 4}
```

这个字典类自动从父类 `MutableMapping` 里继承了 `.update()` 、 `.pop()` 、 `.get()` 等基础的方法。

除了 `MutableMapping` 外，标准库还提供了更高层级的封装，即 `UserDict` ：

```python
from collections import UserDict

class MyDict(UserDict):
    def __setitem__(self, key, value):
        super().__setitem__(key, value * 10)


my_dict = MyDict(a=1, b=2)
print(my_dict)
# 输出:
# {'a': 10, 'b': 20}
```

`UserDict` 将整个数据结构及方法都默认实现了，要改哪个行为，直接覆写对应的方法就好了，很方便。

因此，如果你要自定义容器，非常推荐先在 `collections` 模块里找找现成的轮子，比如 `UserDict` 、 `UserList` 、 `OrderedDict` 等，顺便学习下源码。

## 再看容器

Python 是一门鸭子类型的语言：当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。

翻译成人话就是：只要一个**对象**满足了该**类型**的特定**协议**，那么此**对象**就可以被当成该**类型**使用。

这又引出另外一个问题，什么叫**协议**？协议即某种特定的规范。举个栗子，我们定义“会游泳的动物是鸭子”，这句话里面的“动物”是对象，“鸭子”是类型，“会游泳的”是协议。

理解了这个，那再来看看[Python文档](https://docs.python.org/dev/library/collections.abc.html#collections-abstract-base-classes)中，在**协议**层面上是如何定义容器的：只要对象满足 `__contains__` 协议，那就认为是容器。也就是说下面这就是个简单的容器：

```python
class Container:
    def __contains__(self, value):
        if value == 1:
            return True
        return False
    
container = Container()

print(1 in container)
print(2 in container)
# 输出:
# True
# False
```

你可能会问：那前面实现的自定义序列也没实现 `__contains__` 协议啊？原因是 Python 的幕后机制帮你实现了。想了解的看官方文档[成员测试机制](https://docs.python.org/3/reference/expressions.html#membership-test-details)。

再看看几种内置的容器需要满足的协议：

- **列表**：满足 `MutableSequence` 、 `Sequence` 、`Reversible` 、 `Collection` 等协议。
- **元组**：满足 `Sequence` 、`Reversible` 、 `Collection` 等协议。
- **字典**：满足 `MutableMapping` 、 `Mapping` 、`Collection` 等协议。
- **集合**：满足 `MutableSet` 、 `Set` 、 `Collection` 等协议。

建议阅读官方的[collections.abc](https://docs.python.org/dev/library/collections.abc.html#collections-abstract-base-classes)这个文档，里面把各种容器所需要满足的协议规定得明明白白，还有很多提供给你做基类的宝藏，比如上面用到过的 `MutableMapping` 。

> 包括前面章节里出现过的魔法方法，其实都可以理解为某种协议的一部分。

